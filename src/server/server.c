#include "server.h"

// ------------------------------------------------------------REQUEST FUNCTIONS
void hook_peer()
{
  int confirm;
  Net_ent peer_service_ent = (Net_ent) obj_malloc(NET_ENT);

  // receive the service net_ent of peer
  recv_net_ent(client_fd, peer_service_ent);

  if( network->size == 0 ) // check if new peer is the first
  {
    printf("\nSend 0 to peer with service address: ");
    visit_net_ent(peer_service_ent);
    printf("because it is the first.\nwaiting for genesis block creation...\n");

    send_short(client_fd, 0);

    // read the confirm
    recv_short(client_fd, &confirm);

    if(confirm)
    {
      add_to_list(network, (void*)peer_service_ent);
      printf("Genesis block generated by peer with service address: ");
      visit_net_ent(peer_service_ent);
      printf("which is the only one in p2p network\n");
    }
    else
    {
      printf("Genesis block creation FAILED; peer not addedd to my list\n");
      return;
    }
  }
  else // network->size != 0, the new peer isn't the first
  {
    // minimum number of peers to which the new peer should connect
    int min_peers_number = network->count * MIN_PEERS_PERC;
    if(min_peers_number == 0)
      min_peers_number = 1;

    // send min_peers_number to new_peer
    send_short(client_fd, min_peers_number);

    // response from peer
    int confirmed_conn = 0;
    // counter of succesfull connections
    int count_succ_conn = 0;

    // net_ent to send to the peer for the connection attempt
    Net_ent to_send;

    // index of the peer chosen for the connection
    int i_chosen = rand()%network->size;

    // send min_peers_number net_ent to new peer
    for (int i = 0; i < min_peers_number; i++)
    {
      to_send = search_by_index(network, i_choice);

      printf("Sending to peer with service2");
      visit_net_ent(peer_service_ent);
      printf("this peer: ");
      visit_net_ent(to_send);
      // send peer
      send_net_ent(client_fd, to_send);
      // wait for confirm
      recv_short(connfd, &confirmed_conn);
      // update counter
      if(confirmed_conn)
        succ_connection++;

      /*the next peer to be sent is chosen starting from the index previously
        chosen, to avoid sending equal peers*/
      i_choice =(i_choice + 1) % network->size;
    }

    // check if there is at least one connection
    if (succ_connection > 0)
      add_to_list(network, (void*)peer_listen_ent); // add new peer to network
  }
}


// ----------------------------------------------------------------------UTILITY
// read the parameters passed by command line
void read_cli_param(int argc, char **argv, int* listen_port)
{
  hash_psw = (hash_t) obj_malloc(SHA256_DIGEST_LENGTH);
  hash_psw = NULL;
  *listen_port = 0;

  while ( (opt = getopt(argc, argv, "h:p:")) != -1)
  {
    switch(opt)
    {
      case 'p': // Pasword to encrypt with Sha256
        hash_psw = calculate_hash(optarg);
        printf("Created hash password with SHA256...\n");
        break;

      case 'l': // Listen_port
        *listen_port = atoi(optarg);
        printf("Listen on port %u...\n", *listen_port);
        break;

      case 'h': // Help
      default:
        usage(SERVER_USAGE);
        break;
    }
  }

  if(!listen_port)
  {
    printf("Listen on default port %u...\n", DEFAULT_PORT);
    *listen_port = DEFAULT_PORT;
  }

  if(hash_psw == NULL)
  {
    printf("Created hash password with SHA256 using default test Password...\n");
    hash_psw = calculate_hash(DEFAULT_PSW);
  }
}


// print status of server and network list
void print_status()
{
  printf("\n\nѶ Ѷ Ѷ Ѷ Ѷ Ѷ Ѷ Ѷ Ѷ Ѷ Ѷ Ѷ Ѷ Ѷ Ѷ Ѷ Ѷ Ѷ Ѷ Ѷ Ѷ Ѷ Ѷ Ѷ Ѷ\n\n");
  printf("\tP2P NETWORK:\n\n");
  printf("\n\nѶ Ѷ Ѷ Ѷ Ѷ Ѷ Ѷ Ѷ Ѷ Ѷ Ѷ Ѷ Ѷ Ѷ Ѷ Ѷ Ѷ Ѷ Ѷ Ѷ Ѷ Ѷ Ѷ Ѷ Ѷ\n\n");
  visit_list(network, visit_net_ent);
  printf("\nWaiting for connections...");
}
